# Importamos las bibliotecas necesarias
import streamlit as st  # Importamos streamlit con alias "st".
import os  # Trabajar con comandos del sistema operativo(manejo de rutas).
import time as tm # Trabajar con tiempos.
import random # Generar numeros aleatorios.
import base64 #  Codificar y decodificar datos en base64.
import json # Trabajar con datos JSON.
from PIL import Image  # Manejo de imagenes.
from streamlit_autorefresh import st_autorefresh # Para refrescar la pagina automaticamente usando autorefresh.

# Configuramos la p√°gina de Streamlit
st.set_page_config(page_title="PixMatch", page_icon="üïπÔ∏è", layout="wide", initial_sidebar_state="expanded")

# Obtenemos la letra del disco en el que se est√° ejecutando el script
vDrive = os.path.splitdrive(os.getcwd())[0]
# Establecemos la ruta del proyecto
vpth = "./"

# Definimos el estilo de los emojis en el juego y otros elementos de la interfaz
sbe = """
        <span style='font-size: 140px;
                  border-radius: 7px;
                  text-align: center;
                  display: inline;
                  padding-top: 3px;
                  padding-bottom: 3px;
                  padding-left: 0.4em;
                  padding-right: 0.4em;
                  '>
                  |fill_variable|
        </span>"""


pressed_emoji = """
                    <span style='font-size: 24px;
                            border-radius: 7px;
                            text-align: center;
                            display:inline;
                            padding-top: 3px;
                            padding-bottom: 3px;
                            padding-left: 0.2em;
                            padding-right: 0.2em;
                            '>
                            |fill_variable|
                    </span>
                """

horizontal_bar = """
                <hr style='margin-top: 0; margin-bottom: 0; height: 1px; border: 1px solid #635985;'>
                <br>
"""  # thin divider line

purple_btn_colour = """
                        <style>
                            div.stButton > button:first-child {background-color: #4b0082; color:#ffffff;}
                            div.stButton > button:hover {background-color: RGB(0,112,192); color:#ffffff;}
                            div.stButton > button:focus {background-color: RGB(47,117,181); color:#ffffff;}
                        </style>
                    """

# Inicializamos el estado de la sesi√≥n de Streamlit
mystate = st.session_state

# Inicializamos las variables de estado si no existen
if "expired_cells" not in mystate: mystate.expired_cells = []
if "myscore" not in mystate: mystate.myscore = 0
if "plyrbtns" not in mystate: mystate.plyrbtns = {}
if "sidebar_emoji" not in mystate: mystate.sidebar_emoji = ''
if "emoji_bank" not in mystate: mystate.emoji_bank = []
if "GameDetails" not in mystate: mystate.GameDetails = ['Medium', 6, 7,'']
if "failures" not in mystate: mystate.failures = 0 # (Modificacion no 3)


# Esta funci√≥n ajusta el espacio desde la parte superior de la p√°gina o la barra lateral
def ReduceGapFromPageTop(wch_section='main page'):
    # Si la secci√≥n es la p√°gina principal, ajusta el espacio en la p√°gina principal
    if wch_section == 'main page':
        st.markdown(" <style> div[class^='block-container'] { padding-top: 2rem; } </style> ", True)
    # Si la secci√≥n es la barra lateral, ajusta el espacio en la barra lateral
    elif wch_section == 'sidebar':
        st.markdown(" <style> div[class^='st-emotion-cache-10oheav'] { padding-top: 0rem; } </style> ", True)
    # Si la secci√≥n es 'all', ajusta el espacio tanto en la p√°gina principal como en la barra lateral
    elif wch_section == 'all':
        st.markdown(" <style> div[class^='block-container'] { padding-top: 2rem; } </style> ", True)
        st.markdown(" <style> div[class^='st-emotion-cache-10oheav'] { padding-top: 0rem; } </style> ", True)


# Esta funci√≥n maneja la creaci√≥n, escritura y lectura de la tabla de l√≠deres
def Leaderboard(what_to_do):
    if what_to_do == 'create':
        # Si se proporcion√≥ el nombre del jugador
        if mystate.GameDetails[3] != '':
            # Y si el archivo 'leaderboard.json' no existe
            if os.path.isfile(vpth + 'leaderboard.json') == False:
                # Crea un diccionario vac√≠o y lo escribe en el archivo 'leaderboard.json'
                tmpdict = {}
                json.dump(tmpdict, open(vpth + 'leaderboard.json', 'w'))

    # Si la acci√≥n es 'write'
    elif what_to_do == 'write':
        # Y si se proporcion√≥ el nombre del jugador
        if mystate.GameDetails[3] != '':
            # Y si el archivo 'leaderboard.json' existe
            if os.path.isfile(vpth + 'leaderboard.json'):
                # Lee el archivo 'leaderboard.json'
                leaderboard = json.load(open(vpth + 'leaderboard.json'))
                leaderboard_dict_lngth = len(leaderboard)

                # A√±ade los detalles del juego del jugador al diccionario de la tabla de l√≠deres
                leaderboard[mystate.GameDetails[3]] = {'NameCountry': mystate.GameDetails[3],
                                                       'HighestScore': mystate.myscore}
                # Ordena el diccionario de la tabla de l√≠deres en orden descendente por la puntuaci√≥n m√°s alta
                leaderboard = dict(sorted(leaderboard.items(), key=lambda item: item[1]['HighestScore'], reverse=True))

                # Si la longitud de la tabla de l√≠deres es mayor que 4 (Modificacion no 1)
                if len(leaderboard) > 4:
                    # Elimina los √∫ltimos elementos de la tabla de l√≠deres hasta que su longitud sea 4 (Modificacion no1)
                    for i in range(len(leaderboard) - 4): leaderboard.popitem()

                # Escribe el diccionario de la tabla de l√≠deres en el archivo 'leaderboard.json'
                json.dump(leaderboard, open(vpth + 'leaderboard.json', 'w'))

    # Si la acci√≥n es 'read'
    elif what_to_do == 'read':
        # Y si se proporcion√≥ el nombre del jugador
        if mystate.GameDetails[3] != '':
            # Y si el archivo 'leaderboard.json' existe
            if os.path.isfile(vpth + 'leaderboard.json'):
                # Lee el archivo 'leaderboard.json'
                leaderboard = json.load(open(vpth + 'leaderboard.json'))

                # Ordena el diccionario de la tabla de l√≠deres en orden descendente por la puntuaci√≥n m√°s alta
                leaderboard = dict(sorted(leaderboard.items(), key=lambda item: item[1]['HighestScore'], reverse=True))

                # Crea columnas para mostrar los ganadores pasados
                sc0, sc1, sc2, sc3, sc4 = st.columns((2, 3, 3, 3))
                rknt = 0
                # Para cada clave en la tabla de l√≠deres
                for vkey in leaderboard.keys():
                    # Si el nombre del pa√≠s no est√° vac√≠o
                    if leaderboard[vkey]['NameCountry'] != '':
                        # Incrementa el contador de rango
                        rknt += 1
                        # Mostrar los ganadores segun el rango
                        if rknt == 1:
                            sc0.write('üèÜ Ganadores pasados:')
                            sc1.write(
                                f"ü•á | {leaderboard[vkey]['NameCountry']}: :red[{leaderboard[vkey]['HighestScore']}]")
                        # Si el rango es 2, muestra el segundo ganador
                        elif rknt == 2:
                            sc2.write(
                                f"ü•à | {leaderboard[vkey]['NameCountry']}: :red[{leaderboard[vkey]['HighestScore']}]")
                        # Si el rango es 3, muestra el tercer ganador
                        elif rknt == 3:
                            sc3.write(
                                f"ü•à | {leaderboard[vkey]['NameCountry']}: :red[{leaderboard[vkey]['HighestScore']}]")

                        elif rknt == 4: # (modificacion no2)
                            sc4.write(
                                f"ü•â | {leaderboard[vkey]['NameCountry']}: :red[{leaderboard[vkey]['HighestScore']}]")


# Esta funci√≥n configura la p√°gina inicial del juego
def InitialPage():
    # Configura la barra lateral de Streamlit
    with st.sidebar:
        # Muestra el t√≠tulo del juego y una barra horizontal
        st.subheader("üñºÔ∏è Pix Match:")
        st.markdown(horizontal_bar, True)

        # Abre y redimensiona la imagen del logo de la barra lateral
        sidebarlogo = Image.open('sidebarlogo.jpg').resize((300, 390))
        # Muestra la imagen del logo en la barra lateral
        st.image(sidebarlogo, use_column_width='auto')


    # Define las instrucciones del juego
    hlp_dtl = f"""<span style="font-size: 26px;">
    <ol>
    <li style="font-size:15px";>El juego comienza con (a) una imagen en la barra lateral y (b) una cuadr√≠cula N x N de botones de im√°genes, donde N=6:F√°cil, N=7:Medio, N=8:Dif√≠cil.</li>
    <li style="font-size:15px";>Necesitas hacer coincidir la imagen de la barra lateral con un bot√≥n de imagen de la cuadr√≠cula, presionando el bot√≥n (correspondiente) (lo m√°s r√°pido posible).</li>
    <li style="font-size:15px";>Cada coincidencia correcta de im√°genes te dar√° <strong>+N</strong> puntos (donde N=5:F√°cil, N=3:Medio, N=1:Dif√≠cil); cada coincidencia incorrecta de im√°genes te dar√° <strong>-1</strong> punto.</li>
    <li style="font-size:15px";>La imagen de la barra lateral y las im√°genes de la cuadr√≠cula se regenerar√°n din√°micamente despu√©s de un intervalo de segundos fijo (F√°cil=8, Medio=6, Dif√≠cil=5). Cada regeneraci√≥n tendr√° una penalizaci√≥n de <strong>-1</strong> punto</li>
    <li style="font-size:15px";>Cada uno de los botones de la cuadr√≠cula solo puede ser presionado una vez durante todo el juego.</li>
    <li style="font-size:15px";>El juego se completa cuando todos los botones de la cuadr√≠cula son presionados.</li>
    <li style="font-size:15px";>Al final del juego, si tienes una puntuaci√≥n positiva, habr√°s <strong>ganado</strong>; de lo contrario, habr√°s <strong>perdido</strong>.</li>
    </ol></span>"""

    # Crea dos columnas para mostrar las instrucciones del juego y una imagen de ayuda
    sc1, sc2 = st.columns(2)
    # Establece la semilla para la generaci√≥n de n√∫meros aleatorios
    random.seed()
    # Selecciona una imagen de ayuda aleatoria
    GameHelpImg = vpth + random.choice(["MainImg1.jpg", "MainImg2.jpg", "MainImg3.jpg", "MainImg4.jpg"])
    # Abre y redimensiona la imagen de ayuda
    GameHelpImg = Image.open(GameHelpImg).resize((550, 550))
    # Muestra la imagen de ayuda en la segunda columna
    sc2.image(GameHelpImg, use_column_width='auto')

    # En la primera columna, muestra el t√≠tulo de las instrucciones del juego y una barra horizontal
    sc1.subheader('Reglas | Instrucciones de juego:')
    sc1.markdown(horizontal_bar, True)
    # Muestra las instrucciones del juego
    sc1.markdown(hlp_dtl, unsafe_allow_html=True)
    # Muestra una barra horizontal en la p√°gina principal
    st.markdown(horizontal_bar, True)

    # Muestra los detalles del autor del juego
    author_dtl = "<strong>Juego feliz: üòé Shawn Pereira: shawnpereira1969@gmail.com</strong>"
    st.markdown(author_dtl, unsafe_allow_html=True)


# Esta funci√≥n lee un archivo de imagen y lo codifica en base64
def ReadPictureFile(wch_fl):
    try:
        pxfl = f"{vpth}{wch_fl}"
        return base64.b64encode(open(pxfl, 'rb').read()).decode()
    except:
        return ""


# Esta funci√≥n verifica si un bot√≥n ha sido presionado y actualiza el estado del juego en consecuencia
def PressedCheck(vcell):
    # Si el bot√≥n no ha sido presionado
    if mystate.plyrbtns[vcell]['isPressed'] == False:
        # Marca el bot√≥n como presionado
        mystate.plyrbtns[vcell]['isPressed'] = True
        # Agrega la celda a la lista de celdas expiradas
        mystate.expired_cells.append(vcell)

        # Si el emoji del bot√≥n coincide con el emoji de la barra lateral
        if mystate.plyrbtns[vcell]['eMoji'] == mystate.sidebar_emoji:
            # Marca el bot√≥n como verdadero
            mystate.plyrbtns[vcell]['isTrueFalse'] = True
            # Aumenta la puntuaci√≥n del jugador
            mystate.myscore += 5

            # Ajusta la puntuaci√≥n en funci√≥n del nivel de dificultad
            if mystate.GameDetails[0] == 'Easy':
                mystate.myscore += 5
            elif mystate.GameDetails[0] == 'Medium':
                mystate.myscore += 3
            elif mystate.GameDetails[0] == 'Hard':
                mystate.myscore += 1
        else:
            # Si el emoji del bot√≥n no coincide con el emoji de la barra lateral, marca el bot√≥n como falso
            mystate.plyrbtns[vcell]['isTrueFalse'] = False
            # Disminuye la puntuaci√≥n del jugador
            mystate.myscore -= 1
            # (Modificacion no3)
            mystate.failures += 1  # Incrementamos el contador de fallos



# Esta funci√≥n restablece el tablero de juego
def ResetBoard():
    # Obtiene el n√∫mero total de celdas por fila o columna
    total_cells_per_row_or_col = mystate.GameDetails[2]

    # Selecciona un emoji aleatorio de la lista de emojis para la barra lateral
    sidebar_emoji_no = random.randint(1, len(mystate.emoji_bank)) - 1
    mystate.sidebar_emoji = mystate.emoji_bank[sidebar_emoji_no]

    # Inicializa una variable para verificar si el emoji de la barra lateral est√° en la lista
    sidebar_emoji_in_list = False

    # Recorre todas las celdas del tablero
    for vcell in range(1, ((total_cells_per_row_or_col ** 2) + 1)):
        # Selecciona un emoji aleatorio de la lista de emojis
        rndm_no = random.randint(1, len(mystate.emoji_bank)) - 1

        # Si el bot√≥n no ha sido presionado
        if mystate.plyrbtns[vcell]['isPressed'] == False:
            # Asigna el emoji aleatorio al bot√≥n
            vemoji = mystate.emoji_bank[rndm_no]
            mystate.plyrbtns[vcell]['eMoji'] = vemoji

            # Si el emoji del bot√≥n coincide con el emoji de la barra lateral, marca la variable como verdadera
            if vemoji == mystate.sidebar_emoji: sidebar_emoji_in_list = True

    # Si el emoji de la barra lateral no est√° en ning√∫n bot√≥n, a√±ade el emoji de forma aleatoria
    if sidebar_emoji_in_list == False:
        # Crea una lista de todas las celdas
        tlst = [x for x in range(1, ((total_cells_per_row_or_col ** 2) + 1))]
        # Crea una lista de las celdas que no est√°n en la lista de celdas expiradas
        flst = [x for x in tlst if x not in mystate.expired_cells]

        # Si hay celdas disponibles
        if len(flst) > 0:
            # Selecciona una celda aleatoria de la lista
            lptr = random.randint(0, (len(flst) - 1))
            lptr = flst[lptr]

            # Asigna el emoji de la barra lateral a la celda seleccionada
            mystate.plyrbtns[lptr]['eMoji'] = mystate.sidebar_emoji


# Esta funci√≥n prepara un nuevo juego
def PreNewGame():
    # Obtiene el n√∫mero total de celdas por fila o columna
    total_cells_per_row_or_col = mystate.GameDetails[2]
    # Reinicia las celdas expiradas y la puntuaci√≥n
    mystate.expired_cells = []
    mystate.myscore = 0
    mystate.failures = 0 # (Modificacion no3)

    # Define las listas de emojis
    foxes = ['üò∫', 'üò∏', 'üòπ', 'üòª', 'üòº', 'üòΩ', 'üôÄ', 'üòø', 'üòæ']
    emojis = ['üòÉ', 'üòÑ', 'üòÅ', 'üòÜ', 'üòÖ', 'üòÇ', 'ü§£', 'üòä', 'üòá', 'üôÇ', 'üôÉ', 'üòâ', 'üòå', 'üòç', 'ü•∞', 'üòò', 'üòó', 'üòô', 'üòö', 'üòã', 'üòõ',
              'üòù', 'üòú', 'ü§™', 'ü§®', 'üßê', 'ü§ì', 'üòé', 'ü§©', 'ü•≥', 'üòè', 'üòí', 'üòû', 'üòî', 'üòü', 'üòï', 'üôÅ', '‚òπÔ∏è', 'üò£', 'üòñ', 'üò´', 'üò©',
              'ü•∫', 'üò¢', 'üò†', 'üò≥', 'üò•', 'üòì', 'ü§ó', 'ü§î', 'ü§≠', 'ü§´', 'ü§•', 'üò∂', 'üòê', 'üòë', 'üò¨', 'üôÑ', 'üòØ', 'üòß', 'üòÆ', 'üò≤', 'ü•±',
              'üò¥', 'ü§§', 'üò™', 'üòµ', 'ü§ê', 'ü•¥', 'ü§í']
    humans = ['üë∂', 'üëß', 'üßí', 'üë¶', 'üë©', 'üßë', 'üë®', 'üë©‚Äçü¶±', 'üë®‚Äçü¶±', 'üë©‚Äçü¶∞', '‚Äçüë®', 'üë±', 'üë©', 'üë±', 'üë©‚Äç', 'üë®‚Äçü¶≥', 'üë©‚Äçü¶≤', 'üëµ', 'üßì',
              'üë¥', 'üë≤', 'üë≥']
    foods = ['üçè', 'üçé', 'üçê', 'üçä', 'üçã', 'üçå', 'üçâ', 'üçá', 'üçì', 'üçà', 'üçí', 'üçë', 'ü•≠', 'üçç', 'ü••', 'ü•ù', 'üçÖ', 'üçÜ', 'ü•ë', 'ü•¶', 'ü•¨',
             'ü•í', 'üåΩ', 'ü•ï', 'üßÑ', 'üßÖ', 'ü•î', 'üç†', 'ü•ê', 'ü•Ø', 'üçû', 'ü•ñ', 'ü•®', 'üßÄ', 'ü•ö', 'üç≥', 'üßà', 'ü•û', 'üßá', 'ü•ì', 'ü•©', 'üçó',
             'üçñ', 'ü¶¥', 'üå≠', 'üçî', 'üçü', 'üçï']
    clocks = ['üïì', 'üïí', 'üïë', 'üïò', 'üïõ', 'üïö', 'üïñ', 'üïô', 'üïî', 'üï§', 'üï†', 'üïï', 'üï£', 'üïû', 'üïü', 'üïú', 'üï¢', 'üï¶']
    hands = ['ü§ö', 'üñê', '‚úã', 'üññ', 'üëå', 'ü§è', '‚úåÔ∏è', 'ü§û', 'ü§ü', 'ü§ò', 'ü§ô', 'üëà', 'üëâ', 'üëÜ', 'üñï', 'üëá', '‚òùÔ∏è', 'üëç', 'üëé', '‚úä', 'üëä',
             'ü§õ', 'ü§ú', 'üëè', 'üôå', 'ü§≤', 'ü§ù', 'ü§öüèª', 'üñêüèª', '‚úãüèª', 'üññüèª', 'üëåüèª', 'ü§èüèª', '‚úåüèª', 'ü§ûüèª', 'ü§üüèª', 'ü§òüèª', 'ü§ôüèª', 'üëàüèª',
             'üëâüèª', 'üëÜüèª', 'üñïüèª', 'üëáüèª', '‚òùüèª', 'üëçüèª', 'üëéüèª', '‚úäüèª', 'üëäüèª', 'ü§õüèª', 'ü§úüèª', 'üëèüèª', 'üôåüèª', 'ü§öüèΩ', 'üñêüèΩ', '‚úãüèΩ', 'üññüèΩ',
             'üëåüèΩ', 'ü§èüèΩ', '‚úåüèΩ', 'ü§ûüèΩ', 'ü§üüèΩ', 'ü§òüèΩ', 'ü§ôüèΩ', 'üëàüèΩ', 'üëâüèΩ', 'üëÜüèΩ', 'üñïüèΩ', 'üëáüèΩ', '‚òùüèΩ', 'üëçüèΩ', 'üëéüèΩ', '‚úäüèΩ', 'üëäüèΩ',
             'ü§õüèΩ', 'ü§úüèΩ', 'üëèüèΩ', 'üôåüèΩ']
    animals = ['üê∂', 'üê±', 'üê≠', 'üêπ', 'üê∞', 'ü¶ä', 'üêª', 'üêº', 'üê®', 'üêØ', 'ü¶Å', 'üêÆ', 'üê∑', 'üêΩ', 'üê∏', 'üêµ', 'üôà', 'üôâ', 'üôä', 'üêí', 'üêî',
               'üêß', 'üê¶', 'üê§', 'üê£', 'üê•', 'ü¶Ü', 'ü¶Ö', 'ü¶â', 'ü¶á', 'üê∫', 'üêó', 'üê¥', 'ü¶Ñ', 'üêù', 'üêõ', 'ü¶ã', 'üêå', 'üêû', 'üêú', 'ü¶ü', 'ü¶ó',
               'ü¶Ç', 'üê¢', 'üêç', 'ü¶é', 'ü¶ñ', 'ü¶ï', 'üêô', 'ü¶ë', 'ü¶ê', 'ü¶û', 'ü¶Ä', 'üê°', 'üê†', 'üêü', 'üê¨', 'üê≥', 'üêã', 'ü¶à', 'üêä', 'üêÖ', 'üêÜ',
               'ü¶ì', 'ü¶ç', 'ü¶ß', 'üêò', 'ü¶õ', 'ü¶è', 'üê™', 'üê´', 'ü¶í', 'ü¶ò', 'üêÉ', 'üêÇ', 'üêÑ', 'üêé', 'üêñ', 'üêè', 'üêë', 'ü¶ô', 'üêê', 'ü¶å', 'üêï',
               'üê©', 'ü¶Æ', 'üêï‚Äçü¶∫', 'üêà', 'üêì', 'ü¶É', 'ü¶ö', 'ü¶ú', 'ü¶¢', 'ü¶©', 'üêá', 'ü¶ù', 'ü¶®', 'ü¶¶', 'ü¶•', 'üêÅ', 'üêÄ', 'ü¶î']
    vehicles = ['üöó', 'üöï', 'üöô', 'üöå', 'üöé', 'üöì', 'üöë', 'üöí', 'üöê', 'üöö', 'üöõ', 'üöú', 'ü¶Ø', 'ü¶Ω', 'ü¶º', 'üõ¥', 'üö≤', 'üõµ', 'üõ∫', 'üöî', 'üöç',
                'üöò', 'üöñ', 'üö°', 'üö†', 'üöü', 'üöÉ', 'üöã', 'üöû', 'üöù', 'üöÑ', 'üöÖ', 'üöà', 'üöÇ', 'üöÜ', 'üöá', 'üöä', 'üöâ', '‚úàÔ∏è', 'üõ´', 'üõ¨',
                'üí∫', 'üöÄ', 'üõ∏', 'üöÅ', 'üõ∂', '‚õµÔ∏è', 'üö§', 'üõ≥', '‚õ¥', 'üö¢']
    houses = ['üè†', 'üè°', 'üèò', 'üèö', 'üèó', 'üè≠', 'üè¢', 'üè¨', 'üè£', 'üè§', 'üè•', 'üè¶', 'üè®', 'üè™', 'üè´', 'üè©', 'üíí', 'üèõ', '‚õ™Ô∏è', 'üïå', 'üïç',
              'üõï']
    purple_signs = ['‚òÆÔ∏è', '‚úùÔ∏è', '‚ò™Ô∏è', '‚ò∏Ô∏è', '‚ú°Ô∏è', 'üîØ', 'üïé', '‚òØÔ∏è', '‚ò¶Ô∏è', 'üõê', '‚õé', '‚ôàÔ∏è', '‚ôâÔ∏è', '‚ôäÔ∏è', '‚ôãÔ∏è', '‚ôåÔ∏è', '‚ôçÔ∏è',
                    '‚ôéÔ∏è', '‚ôèÔ∏è', '‚ôêÔ∏è', '‚ôëÔ∏è', '‚ôíÔ∏è', '‚ôìÔ∏è', 'üÜî', 'üà≥']
    red_signs = ['üà∂', 'üàöÔ∏è', 'üà∏', 'üà∫', 'üà∑Ô∏è', '‚ú¥Ô∏è', 'üâê', '„äôÔ∏è', '„äóÔ∏è', 'üà¥', 'üàµ', 'üàπ', 'üà≤', 'üÖ∞Ô∏è', 'üÖ±Ô∏è', 'üÜé', 'üÜë', 'üÖæÔ∏è', 'üÜò',
                 'üöº', 'üõë', '‚õîÔ∏è', 'üìõ', 'üö´', 'üö∑', 'üöØ', 'üö≥', 'üö±', 'üîû', 'üìµ', 'üö≠']
    blue_signs = ['üöæ', '‚ôøÔ∏è', 'üÖøÔ∏è', 'üàÇÔ∏è', 'üõÇ', 'üõÉ', 'üõÑ', 'üõÖ', 'üöπ', 'üö∫', 'üöª', 'üöÆ', 'üé¶', 'üì∂', 'üàÅ', 'üî£', 'üî§', 'üî°', 'üî†', 'üÜñ',
                  'üÜó', 'üÜô', 'üÜí', 'üÜï', 'üÜì', '0Ô∏è‚É£', '1Ô∏è‚É£', '2Ô∏è‚É£', '3Ô∏è‚É£', '4Ô∏è‚É£', '5Ô∏è‚É£', '6Ô∏è‚É£', '7Ô∏è‚É£', '8Ô∏è‚É£', '9Ô∏è‚É£', 'üîü',
                  'üî¢', '‚èèÔ∏è', '‚ñ∂Ô∏è', '‚è∏', '‚èØ', '‚èπ', '‚è∫', '‚è≠', '‚èÆ', '‚è©', '‚è™', '‚è´', '‚è¨', '‚óÄÔ∏è', 'üîº', 'üîΩ', '‚û°Ô∏è', '‚¨ÖÔ∏è', '‚¨ÜÔ∏è',
                  '‚¨áÔ∏è', '‚ÜóÔ∏è', '‚ÜòÔ∏è', '‚ÜôÔ∏è', '‚ÜñÔ∏è', '‚Ü™Ô∏è', '‚Ü©Ô∏è', '‚§¥Ô∏è', '‚§µÔ∏è', 'üîÄ', 'üîÅ', 'üîÇ', 'üîÑ', 'üîÉ', '‚ûø', 'üîö', 'üîô', 'üîõ',
                  'üîù', 'üîú']
    moon = ['üåï', 'üåî', 'üåì', 'üåó', 'üåí', 'üåñ', 'üåë', 'üåú', 'üåõ', 'üåô']

    # Establece la semilla para la generaci√≥n de n√∫meros aleatorios
    random.seed()

    # Selecciona el banco de emojis en funci√≥n del nivel de dificultad
    if mystate.GameDetails[0] == 'Easy':
        wch_bank = random.choice(['foods', 'moon', 'animals'])
        mystate.emoji_bank = locals()[wch_bank]
    elif mystate.GameDetails[0] == 'Medium':
        wch_bank = random.choice(
            ['foxes', 'emojis', 'humans', 'vehicles', 'houses', 'hands', 'purple_signs', 'red_signs', 'blue_signs'])
        mystate.emoji_bank = locals()[wch_bank]
    elif mystate.GameDetails[0] == 'Hard':
        wch_bank = random.choice(
            ['foxes', 'emojis', 'humans', 'foods', 'clocks', 'hands', 'animals', 'vehicles', 'houses', 'purple_signs',
             'red_signs', 'blue_signs', 'moon'])
        mystate.emoji_bank = locals()[wch_bank]

    # Inicializa los botones del jugador
    mystate.plyrbtns = {}
    for vcell in range(1, ((total_cells_per_row_or_col ** 2) + 1)):
        mystate.plyrbtns[vcell] = {'isPressed': False, 'isTrueFalse': False, 'eMoji': ''}


# Esta funci√≥n devuelve un emoji basado en la puntuaci√≥n del jugador
def ScoreEmoji():
    if mystate.myscore == 0:
        return 'üòê'
    elif -5 <= mystate.myscore <= -1:
        return 'üòè'
    elif -10 <= mystate.myscore <= -6:
        return '‚òπÔ∏è'
    elif mystate.myscore <= -11:
        return 'üòñ'
    elif 1 <= mystate.myscore <= 5:
        return 'üôÇ'
    elif 6 <= mystate.myscore <= 10:
        return 'üòä'
    elif mystate.myscore > 10:
        return 'üòÅ'


# Esta funci√≥n inicia un nuevo juego
def NewGame():
    # Llama a la funci√≥n ResetBoard para preparar el tablero de juego
    ResetBoard()
    # Obtiene el n√∫mero total de celdas por fila o columna
    total_cells_per_row_or_col = mystate.GameDetails[2]

    # Configura la barra lateral de Streamlit
    ReduceGapFromPageTop('sidebar')
    with st.sidebar:
        # Muestra el t√≠tulo del juego y una barra horizontal
        st.subheader(f"üñºÔ∏è Pix Match: {mystate.GameDetails[0]}")
        st.markdown(horizontal_bar, True)

        # Muestra el emoji de la barra lateral
        st.markdown(sbe.replace('|fill_variable|', mystate.sidebar_emoji), True)

        # Configura un temporizador de autorefresco y disminuye la puntuaci√≥n del jugador si el temporizador es mayor que 0
        aftimer = st_autorefresh(interval=(mystate.GameDetails[1] * 1000), key="aftmr")
        if aftimer > 0: mystate.myscore -= 1

        # Muestra la puntuaci√≥n del jugador y el n√∫mero de celdas pendientes
        st.info(
            f"{ScoreEmoji()} Score: {mystate.myscore} | Pending: {(total_cells_per_row_or_col ** 2) - len(mystate.expired_cells)}")

        # Muestra una barra horizontal y un bot√≥n para volver a la p√°gina principal
        st.markdown(horizontal_bar, True)
        if st.button(f"üîô Return to Main Page", use_container_width=True):
            mystate.runpage = Main
            st.rerun()

    # Llama a la funci√≥n Leaderboard para mostrar la tabla de l√≠deres
    Leaderboard('read')
    # Muestra el t√≠tulo de las posiciones de las im√°genes y una barra horizontal
    st.subheader("Picture Positions:")
    st.markdown(horizontal_bar, True)

    # Configura el tama√±o de los emojis en los botones
    st.markdown("<style> div[class^='css-1vbkxwb'] > p { font-size: 1.5rem; } </style> ", unsafe_allow_html=True)

    # Crea las columnas para los botones del tablero de juego
    for i in range(1, (total_cells_per_row_or_col + 1)):
        tlst = ([1] * total_cells_per_row_or_col) + [2]  # 2 = rt side padding
        globals()['cols' + str(i)] = st.columns(tlst)

    # Rellena el tablero de juego con los botones
    for vcell in range(1, (total_cells_per_row_or_col ** 2) + 1):
        # Determina la fila del bot√≥n en funci√≥n de su n√∫mero
        if 1 <= vcell <= (total_cells_per_row_or_col * 1):
            arr_ref = '1'
            mval = 0
        elif ((total_cells_per_row_or_col * 1) + 1) <= vcell <= (total_cells_per_row_or_col * 2):
            arr_ref = '2'
            mval = (total_cells_per_row_or_col * 1)
        if 1 <= vcell <= (total_cells_per_row_or_col * 1):
            arr_ref = '1'
            mval = 0

        elif ((total_cells_per_row_or_col * 1) + 1) <= vcell <= (total_cells_per_row_or_col * 2):
            arr_ref = '2'
            mval = (total_cells_per_row_or_col * 1)

        elif ((total_cells_per_row_or_col * 2) + 1) <= vcell <= (total_cells_per_row_or_col * 3):
            arr_ref = '3'
            mval = (total_cells_per_row_or_col * 2)

        elif ((total_cells_per_row_or_col * 3) + 1) <= vcell <= (total_cells_per_row_or_col * 4):
            arr_ref = '4'
            mval = (total_cells_per_row_or_col * 3)

        elif ((total_cells_per_row_or_col * 4) + 1) <= vcell <= (total_cells_per_row_or_col * 5):
            arr_ref = '5'
            mval = (total_cells_per_row_or_col * 4)

        elif ((total_cells_per_row_or_col * 5) + 1) <= vcell <= (total_cells_per_row_or_col * 6):
            arr_ref = '6'
            mval = (total_cells_per_row_or_col * 5)

        elif ((total_cells_per_row_or_col * 6) + 1) <= vcell <= (total_cells_per_row_or_col * 7):
            arr_ref = '7'
            mval = (total_cells_per_row_or_col * 6)

        elif ((total_cells_per_row_or_col * 7) + 1) <= vcell <= (total_cells_per_row_or_col * 8):
            arr_ref = '8'
            mval = (total_cells_per_row_or_col * 7)

        elif ((total_cells_per_row_or_col * 8) + 1) <= vcell <= (total_cells_per_row_or_col * 9):
            arr_ref = '9'
            mval = (total_cells_per_row_or_col * 8)

        elif ((total_cells_per_row_or_col * 9) + 1) <= vcell <= (total_cells_per_row_or_col * 10):
            arr_ref = '10'
            mval = (total_cells_per_row_or_col * 9)

        globals()['cols' + arr_ref][vcell - mval] = globals()['cols' + arr_ref][vcell - mval].empty()

        # Si el bot√≥n ha sido presionado, muestra un emoji de verificaci√≥n o de error en funci√≥n de si la elecci√≥n fue correcta o no
        if mystate.plyrbtns[vcell]['isPressed'] == True:
            if mystate.plyrbtns[vcell]['isTrueFalse'] == True:
                globals()['cols' + arr_ref][vcell - mval].markdown(pressed_emoji.replace('|fill_variable|', '‚úÖÔ∏è'), True)
            elif mystate.plyrbtns[vcell]['isTrueFalse'] == False:
                globals()['cols' + arr_ref][vcell - mval].markdown(pressed_emoji.replace('|fill_variable|', '‚ùå'), True)

        # Si el bot√≥n no ha sido presionado, muestra el emoji correspondiente y configura la acci√≥n al hacer clic en el bot√≥n
        else:
            vemoji = mystate.plyrbtns[vcell]['eMoji']
            globals()['cols' + arr_ref][vcell - mval].button(vemoji, on_click=PressedCheck, args=(vcell,),
                                                             key=f"B{vcell}")
    # A√±ade un espacio vertical
    st.caption('')
    # A√±ade una barra horizontal
    st.markdown(horizontal_bar, True)

    # Comprueba si todas las celdas han sido presionadas o si el jugador ha perdido (Modificacion no3)
    if len(mystate.expired_cells) == (total_cells_per_row_or_col ** 2) or mystate.failures > (total_cells_per_row_or_col ** 2) / 2:
        # Si todas las celdas han sido presionadas, escribe los resultados en la tabla de l√≠deres
        Leaderboard('write')

        # Si la puntuaci√≥n del jugador es positiva, muestra globos
        if mystate.myscore > 0:
            st.balloons()
        # Si la puntuaci√≥n del jugador es cero o negativa, muestra nieve
        elif mystate.myscore <= 0:
            st.snow()

        # Espera 5 segundos
        tm.sleep(5)
        # Cambia la p√°gina a la p√°gina principal
        mystate.runpage = Main
        # Recarga la p√°gina
        st.rerun()


# Esta funci√≥n configura la p√°gina principal del juego
def Main():
    # Reduce el ancho de la barra lateral de Streamlit
    st.markdown('<style>[data-testid="stSidebar"] > div:first-child {width: 310px;}</style>', unsafe_allow_html=True, )
    # Configura el color del bot√≥n
    st.markdown(purple_btn_colour, unsafe_allow_html=True)

    # Llama a la funci√≥n InitialPage para configurar la p√°gina inicial
    InitialPage()
    # Configura la barra lateral de Streamlit
    with st.sidebar:
        # Permite al jugador seleccionar el nivel de dificultad
        mystate.GameDetails[0] = st.radio('Difficulty Level:', options=('Easy', 'Medium', 'Hard'), index=1,
                                          horizontal=True, )
        # Permite al jugador introducir su nombre y pa√≠s (opcional)
        mystate.GameDetails[3] = st.text_input("Player Name, Country", placeholder='Shawn Pereira, India',
                                               help='Optional input only for Leaderboard')

        # Si el jugador pulsa el bot√≥n "Nuevo juego"
        if st.button(f"üïπÔ∏è New Game", use_container_width=True):
            # Configura los detalles del juego en funci√≥n del nivel de dificultad seleccionado
            if mystate.GameDetails[0] == 'Easy':
                mystate.GameDetails[1] = 8  # intervalo en segundos
                mystate.GameDetails[2] = 6  # total de celdas por fila o columna

            elif mystate.GameDetails[0] == 'Medium':
                mystate.GameDetails[1] = 6  # intervalo en segundos
                mystate.GameDetails[2] = 7  # total de celdas por fila o columna

            elif mystate.GameDetails[0] == 'Hard':
                mystate.GameDetails[1] = 5  # intervalo en segundos
                mystate.GameDetails[2] = 8  # total de celdas por fila o columna

            # Crea la tabla de l√≠deres
            Leaderboard('create')

            # Prepara el nuevo juego
            PreNewGame()
            # Configura la p√°gina para ejecutar el nuevo juego
            mystate.runpage = NewGame
            # Recarga la p√°gina
            st.rerun()

        # Muestra una barra horizontal en la barra lateral
        st.markdown(horizontal_bar, True)


# Si la p√°gina a ejecutar no est√° en el estado de la sesi√≥n, configura la p√°gina a ejecutar como Main
if 'runpage' not in mystate: mystate.runpage = Main
# Ejecuta la p√°gina configurada
mystate.runpage()
